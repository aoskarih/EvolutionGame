# Arttu Hyv√∂nen 11/2017

import numpy as np
import random
from scipy.special import expit

# actions: move: 0 up, 1 down, 2 left, 3 right,,
# 4 eat, 5 reproduce
output_neurons = 6

# movement energy penalty
movement_energy = 0.05

# eating energy penalty
eating_energy = 0.05

# eating speed (%)
eating_speed = 0.25

# energy passed to child (%)
child_energy = 0.25

# energy lost in reproducing
reproduce_energy = 0.3

# energy lost by default
standing_energy = 0.05

# neurons in hidden layer
hid_neurons = 10

# lenght of visual
sight = 2

# Mutation rate
mr = 1

# Weight magnitude
wm = 10

# regrowth speed
reg_speed = 0.002


class World:

    def __init__(self, size):
        self.size = size
        self.values = np.random.random((self.size, self.size))

    def update(self, regrowth):
        g = np.ones((self.size, self.size))
        g *= regrowth
        self.values += g
        np.clip(self.values, 0, 1, out=self.values)


class Network:

    def __init__(self, neurons_1, neurons_2, neurons_3,
                 w1=None, w2=None, b1=None, b2=None):
        
        if w1 is not None:
            self.w1 = np.clip(w1 + np.random.uniform(-mr, mr, (neurons_2, neurons_1)), -wm, wm)
            self.w2 = np.clip(w2 + np.random.uniform(-mr, mr, (neurons_3, neurons_2)), -wm, wm)
            self.b1 = np.clip(b1 + np.random.uniform(-mr, mr, neurons_2), -wm, wm)
            self.b2 = np.clip(b2 + np.random.uniform(-mr, mr, neurons_3), -wm, wm)
            return

        self.w1 = np.random.randint(-wm, wm, size=(neurons_2, neurons_1))
        self.w2 = np.random.randint(-wm, wm, size=(neurons_3, neurons_2))
        self.b1 = np.random.randint(-wm, wm, size=neurons_2)
        self.b2 = np.random.randint(-wm, wm, size=neurons_3)

    def output(self, a0):
        a1 = expit(np.dot(self.w1, a0) + self.b1)
        return expit(np.dot(self.w2, a1) + self.b2)


class Organism:

    def __init__(self, place, brain_neurons, sight,
                 energy=1, w1=None, w2=None, b1=None, b2=None):
        self.energy = energy
        self.place = place
        self.brain_neurons = brain_neurons
        self.sight = sight
        in_sight = (2*sight+1)*(2*sight+1)
        self.input_neurons = in_sight + 1
        if w1 is not None:
            self.brain = Network(self.input_neurons, brain_neurons, output_neurons, w1, w2, b1, b2)
        else:
            self.brain = Network(self.input_neurons, brain_neurons, output_neurons)

    def action(self, world):
        action_val = self.brain.output(np.insert(self.visual_input(world), 0, self.energy))        
        action = random.choice(np.where(action_val == action_val.max()))
        action_result = 0

        if self.energy <= 0:
            return "dead"
        print(action_val)
        print(action)
        if int(action) == 0:
            # move up
            if self.place[1] < world.size - 1:
                self.place[1] += 1
                self.energy -= movement_energy
        elif int(action) == 1:
            # move down
            if self.place[1] > 0:
                self.place[1] -= 1
                self.energy -= movement_energy
        elif int(action) == 2:
            # move left
            if self.place[0] > 0:
                self.place[0] -= 1
                self.energy -= movement_energy
        elif int(action) == 3:
            # move right
            if self.place[0] < world.size - 1:
                self.place[0] += 1
                self.energy -= movement_energy
        elif int(action) == 4:
            # eat
            self.energy += world.values[self.place[0], self.place[1]]*eating_speed
            action_result = -world.values[self.place[0], self.place[1]]*eating_speed
            self.energy -= eating_energy
        elif int(action) == 5:
            # reproduce
            self.energy -= self.energy*child_energy
            action_result = Organism(self.place, self.brain_neurons, self.sight,
                                     energy=self.energy*child_energy,
                                     w1=self.brain.w1, w2=self.brain.w2,
                                     b1=self.brain.b1, b2=self.brain.b2)
            self.energy -= reproduce_energy

        self.energy -= standing_energy
        return [action_result, int(action)]

    def visual_input(self, world):
        x0, y0 = self.place[0]-self.sight, self.place[1]-self.sight
        size = 2*self.sight+1
        visual = np.empty((size, size))
        for i in range(size):
            for j in range(size):
                if x0+i < 0 or x0+i > world.size - 1 or y0+j < 0 or y0+j > world.size - 1:
                    visual[i, j] = 0
                else:
                    visual[i, j] = world.values[x0+i, y0+j]

        return visual.flatten()


class Game:

    def __init__(self, world_size, num_of_organisms):
        self.world = World(world_size)
        self.organisms = []
        for i in range(num_of_organisms):
            self.organisms.append(Organism(np.random.randint(0, world_size, 2), hid_neurons, sight))

    def simulate(self, max_time):

        # elapsed iterations
        t = 0

        while t < max_time:

            self.world.update(reg_speed)
            new_born = []
            for o in self.organisms:
                result = o.action(self.world)
                if result == "dead":
                    print("Someone died!")
                    self.organisms.remove(o)
                elif result[1] == 4:
                    self.world.values[o.place] -= result[0]
                elif result[1] == 5:
                    new_born.append(result[0])

            self.organisms += new_born
            
            t += 1
            print("time spend: "+str(t))
            
            if self.organisms == []:
                print("Everyone died.  :(")
                break


if __name__ == "__main__":
    game = Game(30, 30)
    game.simulate(1000)
